"""
Test de v√©rification pour le Niveau 4 - Syst√®me Multi-Zones
V√©rifie toutes les am√©liorations du syst√®me d'irrigation multi-zones

Auteur: HITEMA IoT Team
Date: D√©cembre 2024
Version: Level 4
"""

import time
import json
import sqlite3
import threading
import subprocess
import sys
from datetime import datetime
import paho.mqtt.client as mqtt

MQTT_BROKER = "broker.mqttdashboard.com"
MQTT_CONTROL_TOPIC = "irrigation-control"
MQTT_EVENTS_TOPIC = "irrigation-events"
MQTT_SENSOR_TOPIC = "wokwi-weather"

class Level4MultiZoneTest:
    def __init__(self):
        self.test_passed = 0
        self.test_failed = 0
        self.mqtt_messages = []
        self.irrigation_events = []
        self.sensor_data = []
        
        # Expected zones for Level 4
        self.expected_zones = {
            "zone_001": {
                "name": "Paris Garden",
                "location": "Paris",
                "coordinates": (48.8566, 2.3522),
                "pin_dht": 4,
                "pin_servo": 18
            },
            "zone_002": {
                "name": "Milan Greenhouse", 
                "location": "Milan",
                "coordinates": (45.4642, 9.1900),
                "pin_dht": 2,
                "pin_servo": 19
            },
            "zone_003": {
                "name": "Geneva Research Station",
                "location": "Geneva",
                "coordinates": (46.2044, 6.1432),
                "pin_dht": 15,
                "pin_servo": 21
            }
        }
        
        self.client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION1, "level4_test_client")
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        
    def on_connect(self, client, userdata, flags, rc):
        print(f"üì° Test client connected to MQTT broker (rc={rc})")
        client.subscribe(MQTT_EVENTS_TOPIC)
        client.subscribe(MQTT_SENSOR_TOPIC)
        
    def on_message(self, client, userdata, msg):
        try:
            data = json.loads(msg.payload.decode())
            data['timestamp'] = time.time()
            data['topic'] = msg.topic
            
            self.mqtt_messages.append(data)
            
            if msg.topic == MQTT_EVENTS_TOPIC:
                self.irrigation_events.append(data)
            elif msg.topic == MQTT_SENSOR_TOPIC:
                self.sensor_data.append(data)
                
        except Exception as e:
            print(f"‚ùå Error processing MQTT message: {e}")
    
    def print_test_header(self, test_name):
        print(f"\n{'='*60}")
        print(f"üß™ TEST: {test_name}")
        print(f"{'='*60}")
        
    def check_result(self, condition, test_description):
        if condition:
            print(f"‚úÖ {test_description}")
            self.test_passed += 1
            return True
        else:
            print(f"‚ùå {test_description}")
            self.test_failed += 1
            return False
    
    def test_file_existence(self):
        """Test 1: V√©rifier l'existence des fichiers Level 4"""
        self.print_test_header("Existence des fichiers Level 4")
        
        required_files = [
            "main_level4_multi_irrigation.py",
            "multi_zone_controller.py",
            "diagram.json",
            "app.py",
            "database.db"
        ]
        
        for file_name in required_files:
            try:
                with open(file_name, 'r', encoding='utf-8') as f:
                    content = f.read()
                self.check_result(len(content) > 0, f"Fichier {file_name} existe et n'est pas vide")
            except FileNotFoundError:
                self.check_result(False, f"Fichier {file_name} trouv√©")
            except Exception as e:
                self.check_result(False, f"Erreur lors de la lecture de {file_name}: {e}")
    
    def test_multi_zone_configuration(self):
        """Test 2: V√©rifier la configuration multi-zones"""
        self.print_test_header("Configuration Multi-Zones")
        
        try:
            with open("main_level4_multi_irrigation.py", 'r', encoding='utf-8') as f:
                content = f.read()
            
            # V√©rifier les configurations de zones
            for zone_id, zone_info in self.expected_zones.items():
                zone_found = zone_id in content
                self.check_result(zone_found, f"Zone {zone_id} ({zone_info['location']}) configur√©e")
                
                location_found = zone_info['location'] in content
                self.check_result(location_found, f"Location {zone_info['location']} trouv√©e")
                
                # V√©rifier les coordonn√©es GPS
                lat_str = str(zone_info['coordinates'][0])
                lon_str = str(zone_info['coordinates'][1])
                coords_found = lat_str in content and lon_str in content
                self.check_result(coords_found, f"Coordonn√©es GPS pour {zone_info['location']} trouv√©es")
            
            # V√©rifier les pins DHT et servo
            pin_configs = ["dht_pins", "servo_pins", "PWM"]
            for config in pin_configs:
                config_found = config in content
                self.check_result(config_found, f"Configuration {config} trouv√©e")
                
        except Exception as e:
            print(f"‚ùå Erreur lors du test de configuration: {e}")
    
    def test_mqtt_multi_zone_topics(self):
        """Test 3: V√©rifier les topics MQTT multi-zones"""
        self.print_test_header("Topics MQTT Multi-Zones")
        
        # Start MQTT client
        self.client.connect(MQTT_BROKER, 1883, 60)
        self.client.loop_start()
        
        print("üì° Connexion au broker MQTT...")
        time.sleep(2)
        
        # Test zone-specific commands
        test_commands = [
            {"command": "irrigation_on", "zone_id": "zone_001"},
            {"command": "irrigation_off", "zone_id": "zone_002"},
            {"command": "set_threshold", "zone_id": "zone_003", "threshold": 45},
            {"command": "system_status", "zone_id": "all"}
        ]
        
        for cmd in test_commands:
            message = json.dumps(cmd)
            result = self.client.publish(MQTT_CONTROL_TOPIC, message)
            
            zone_desc = f"Zone {cmd['zone_id']}" if cmd['zone_id'] != "all" else "Toutes zones"
            self.check_result(result.rc == 0, f"Commande '{cmd['command']}' envoy√©e √† {zone_desc}")
            time.sleep(0.5)
        
        self.client.loop_stop()
        self.client.disconnect()
    
    def test_database_multi_zone_schema(self):
        """Test 4: V√©rifier le sch√©ma base de donn√©es multi-zones"""
        self.print_test_header("Sch√©ma Base de Donn√©es Multi-Zones")
        
        try:
            conn = sqlite3.connect('database.db')
            cursor = conn.cursor()
            
            # V√©rifier la table sensor_data avec support multi-zones
            cursor.execute("PRAGMA table_info(sensor_data)")
            columns = [row[1] for row in cursor.fetchall()]
            
            required_columns = ['id', 'timestamp', 'temperature', 'humidity', 'zone_id', 'location']
            for col in required_columns:
                col_exists = col in columns
                self.check_result(col_exists, f"Colonne '{col}' dans table sensor_data")
            
            # V√©rifier la table irrigation_events avec zones
            cursor.execute("PRAGMA table_info(irrigation_events)")
            columns = [row[1] for row in cursor.fetchall()]
            
            irrigation_columns = ['id', 'timestamp', 'event', 'zone_id', 'humidity', 'threshold']
            for col in irrigation_columns:
                col_exists = col in columns
                self.check_result(col_exists, f"Colonne '{col}' dans table irrigation_events")
            
            # V√©rifier s'il y a des donn√©es multi-zones
            cursor.execute("SELECT DISTINCT zone_id FROM sensor_data WHERE zone_id IS NOT NULL")
            zones_in_db = [row[0] for row in cursor.fetchall()]
            
            zones_found = len(zones_in_db) > 0
            self.check_result(zones_found, f"Donn√©es multi-zones trouv√©es: {zones_in_db}")
            
            conn.close()
            
        except Exception as e:
            print(f"‚ùå Erreur lors du test base de donn√©es: {e}")
    
    def test_wokwi_multi_sensor_diagram(self):
        """Test 5: V√©rifier le diagramme Wokwi multi-capteurs"""
        self.print_test_header("Diagramme Wokwi Multi-Capteurs")
        
        try:
            with open("diagram.json", 'r', encoding='utf-8') as f:
                diagram = json.load(f)
            
            parts = diagram.get('parts', [])
            connections = diagram.get('connections', [])
            
            # V√©rifier les composants attendus
            expected_components = {
                'esp32': 1,
                'dht22': 3,  # 3 DHT22 pour 3 zones
                'servo': 3   # 3 servos pour 3 zones
            }
            
            for part_type, expected_count in expected_components.items():
                actual_count = sum(1 for part in parts if part_type in part.get('type', ''))
                self.check_result(
                    actual_count >= expected_count,
                    f"Au moins {expected_count} composant(s) {part_type} trouv√©(s) ({actual_count})"
                )
            
            # V√©rifier les connexions multiples
            connection_count = len(connections)
            min_expected_connections = 20  # ESP32 + 3 DHT22 + 3 servos = nombreuses connexions
            self.check_result(
                connection_count >= min_expected_connections,
                f"Connexions suffisantes trouv√©es ({connection_count}/{min_expected_connections})"
            )
            
            # V√©rifier les pins sp√©cifiques
            connection_str = str(connections)
            expected_pins = ["18", "19", "21", "4", "2", "15"]  # Servo et DHT pins
            for pin in expected_pins:
                pin_found = f":{pin}" in connection_str or f"D{pin}" in connection_str
                self.check_result(pin_found, f"Pin {pin} utilis√©e dans les connexions")
                
        except Exception as e:
            print(f"‚ùå Erreur lors du test diagramme: {e}")
    
    def test_controller_multi_zone_features(self):
        """Test 6: V√©rifier les fonctionnalit√©s du contr√¥leur multi-zones"""
        self.print_test_header("Fonctionnalit√©s Contr√¥leur Multi-Zones")
        
        try:
            with open("multi_zone_controller.py", 'r', encoding='utf-8') as f:
                controller_content = f.read()
            
            # V√©rifier les fonctionnalit√©s multi-zones
            multi_zone_features = [
                "MultiZoneIrrigationController",
                "zone_001",
                "zone_002", 
                "zone_003",
                "Paris",
                "Milan",
                "Geneva",
                "turn_on_zone",
                "turn_off_zone",
                "set_zone_threshold",
                "show_zone_status",
                "LOCATIONS" # Pour v√©rifier la compatibilit√© avec ESP32
            ]
            
            for feature in multi_zone_features:
                feature_found = feature in controller_content
                self.check_result(feature_found, f"Fonctionnalit√© '{feature}' impl√©ment√©e")
            
            # V√©rifier les coordonn√©es GPS des zones
            gps_coordinates = ["48.8566", "45.4642", "46.2044"]  # Paris, Milan, Geneva
            for coord in gps_coordinates:
                coord_found = coord in controller_content
                self.check_result(coord_found, f"Coordonn√©e GPS {coord} trouv√©e")
                
        except Exception as e:
            print(f"‚ùå Erreur lors du test contr√¥leur: {e}")
    
    def test_level4_improvements(self):
        """Test 7: V√©rifier les am√©liorations sp√©cifiques au Level 4"""
        self.print_test_header("Am√©liorations Level 4")
        
        improvements_found = {
            "multi_zone": False,
            "gps_coordinates": False,
            "zone_specific_thresholds": False,
            "individual_servo_control": False,
            "enhanced_mqtt": False
        }
        
        # V√©rifier main_level4_multi_irrigation.py
        try:
            with open("main_level4_multi_irrigation.py", 'r', encoding='utf-8') as f:
                main_content = f.read()
            
            if "LOCATIONS" in main_content and len([line for line in main_content.split('\n') if 'zone_' in line]) >= 3:
                improvements_found["multi_zone"] = True
            
            if "latitude" in main_content and "longitude" in main_content:
                improvements_found["gps_coordinates"] = True
            
            if "threshold" in main_content and "zone_" in main_content:
                improvements_found["zone_specific_thresholds"] = True
            
            if "servo_pins" in main_content and "PWM" in main_content:
                improvements_found["individual_servo_control"] = True
            
            if "zone_id" in main_content and "MQTT" in main_content:
                improvements_found["enhanced_mqtt"] = True
                
        except Exception as e:
            print(f"‚ùå Erreur lors de la v√©rification des am√©liorations: {e}")
        
        # V√©rifier les r√©sultats
        for improvement, found in improvements_found.items():
            self.check_result(found, f"Am√©lioration Level 4: {improvement.replace('_', ' ').title()}")
    
    def run_comprehensive_test(self):
        """Ex√©cuter tous les tests Level 4"""
        print("üåç TESTS DE V√âRIFICATION LEVEL 4 - SYST√àME MULTI-ZONES")
        print("="*70)
        print("V√©rification des am√©liorations et fonctionnalit√©s multi-zones")
        print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*70)
        
        # Ex√©cuter tous les tests
        self.test_file_existence()
        self.test_multi_zone_configuration()
        self.test_mqtt_multi_zone_topics()
        self.test_database_multi_zone_schema()
        self.test_wokwi_multi_sensor_diagram()
        self.test_controller_multi_zone_features()
        self.test_level4_improvements()
        
        # R√©sum√© final
        total_tests = self.test_passed + self.test_failed
        success_rate = (self.test_passed / total_tests * 100) if total_tests > 0 else 0
        
        print(f"\n{'='*70}")
        print("üèÜ R√âSUM√â DES TESTS LEVEL 4")
        print(f"{'='*70}")
        print(f"‚úÖ Tests r√©ussis: {self.test_passed}")
        print(f"‚ùå Tests √©chou√©s: {self.test_failed}")
        print(f"üìä Taux de r√©ussite: {success_rate:.1f}%")
        
        if success_rate >= 90:
            print("üéâ EXCELLENT! Level 4 Multi-Zones pr√™t pour production!")
        elif success_rate >= 75:
            print("‚úÖ BIEN! Level 4 fonctionnel avec quelques am√©liorations possibles")
        elif success_rate >= 50:
            print("‚ö†Ô∏è  MOYEN. Plusieurs points √† corriger")
        else:
            print("‚ùå ATTENTION! Corrections importantes n√©cessaires")
        
        # Recommandations Level 4
        print(f"\nüìã RECOMMANDATIONS LEVEL 4:")
        print("1. V√©rifier les 3 zones (Paris, Milan, Geneva) configur√©es")
        print("2. Tester l'irrigation individuelle par zone")
        print("3. Valider les coordonn√©es GPS de chaque zone")
        print("4. V√©rifier les seuils d'humidit√© sp√©cifiques par zone")
        print("5. Tester les commandes MQTT zone-sp√©cifiques")
        print("6. Pr√©parer pour les am√©liorations additionnelles:")
        print("   - D√©tection d'intrusion avec OpenCV")
        print("   - Classification des maladies des plantes")
        print("   - Int√©gration ESP32 physique")
        
        print(f"\n{'='*70}")
        return success_rate >= 75

if __name__ == "__main__":
    print("üß™ Lancement des tests Level 4 Multi-Zones...")
    test_suite = Level4MultiZoneTest()
    success = test_suite.run_comprehensive_test()
    
    if success:
        print("\nüéØ Level 4 Multi-Zones valid√©! Pr√™t pour les am√©liorations avanc√©es.")
    else:
        print("\n‚ö†Ô∏è Quelques ajustements n√©cessaires avant finalisation.")
    
    sys.exit(0 if success else 1)
